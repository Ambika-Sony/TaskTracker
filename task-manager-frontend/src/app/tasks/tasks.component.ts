
// This file contains the logic for displaying and managing tasks.

import { Component, OnInit } from '@angular/core';    // Core Angular modules
import { CommonModule } from '@angular/common';       // For NgIf, NgFor directives in template
import { FormsModule } from '@angular/forms';         // For [(ngModel)] two-way data binding
import { TaskService } from '../task.service';        // Our custom service for backend communication
import { HttpErrorResponse } from '@angular/common/http';

// Define the structure of a Task object to match our Spring Boot backend
interface Task {
  id?: number;          // Optional, as it's auto-generated by the backend on creation
  title: string;
  description: string;
  dueDate: string;      // Using string for date handling between frontend and backend
  completed: boolean;
  tags?: string[];      // Optional array of strings for tags
}

@Component({
  selector: 'app-tasks', // How this component will be used in HTML (e.g., <app-tasks></app-tasks>)
  standalone: true,      // Marks this component as standalone, requiring explicit imports
  imports: [CommonModule, FormsModule], // Essential modules for template functionality
  templateUrl: './tasks.component.html', // Points to the HTML template for this component
  styleUrl: './tasks.component.css'    // Points to the CSS styles for this component
})
export class TasksComponent implements OnInit {

  tasks: Task[] = [];
  newTaskTitle: string = '';
  newTaskDescription: string = '';
  newTaskDueDate: string = '';

  constructor(private taskService: TaskService) { }

  ngOnInit(): void {
    this.getTasks();
  }

  getTasks(): void {
    this.taskService.getTasks().subscribe({
      next: (tasks: Task[]) => this.tasks = tasks, // <--- Add : Task[]
      error: (err: HttpErrorResponse) => console.error('Error fetching tasks:', err) // <--- Add : HttpErrorResponse
    });
  }

  addTask(): void {
    if (!this.newTaskTitle || !this.newTaskDueDate) {
      alert('Title and Due Date are required!');
      return;
    }

    const newTask: Task = {
      title: this.newTaskTitle,
      description: this.newTaskDescription,
      dueDate: this.newTaskDueDate,
      completed: false,
      tags: []
    };

    this.taskService.addTask(newTask).subscribe({
      next: (task: Task) => { // <--- Add : Task
        this.tasks.push(task);
        this.newTaskTitle = '';
        this.newTaskDescription = '';
        this.newTaskDueDate = '';
      },
      error: (err: HttpErrorResponse) => console.error('Error adding task:', err) // <--- Add : HttpErrorResponse
    });
  }
toggleCompletion(task: Task): void {
    // The service method now handles flipping the status and calling the backend update
    this.taskService.toggleTaskCompletion(task) // Pass the entire task object to the service
      .subscribe({
        next: (updatedTask) => {
          console.log('Task updated:', updatedTask);
          // After successful update, find the task in the local array and update it
          const index = this.tasks.findIndex(t => t.id === updatedTask.id);
          if (index !== -1) {
            this.tasks[index] = updatedTask; // Update the task in the local array
          }
        },
        error: (error) => {
          console.error('Error toggling completion:', error);
          // If the update fails, re-fetch all tasks to ensure UI is in sync with backend
          this.getTasks();
        }
      });
  }

  deleteTask(id?: number): void {
    if (id === undefined) return;

    this.taskService.deleteTask(id).subscribe({
      next: () => {
        this.tasks = this.tasks.filter(task => task.id !== id);
      },
      error: (err: HttpErrorResponse) => console.error('Error deleting task:', err) // <--- Add : HttpErrorResponse
    });
  }
}